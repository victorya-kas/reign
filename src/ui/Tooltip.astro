---
import type { tooltip } from "@ts/types";

interface Props {
  id: string;
  content: tooltip;
}
const { content, id } = Astro.props as Props;
---

<div tooltip-for={id} tooltip-content={JSON.stringify(content)} class="hidden">
</div>
<style is:global>
  [highligted-tooltips-id] {
    height: 0;
    width: 0;
  }
  [highligted-tooltips-id] > * {
    position: absolute !important;
    z-index: 500 !important;
  }
  [origin-highlighted] {
    opacity: 0;
  }
</style>
<script>
  import type { tooltip } from "@ts/types";

  type tooltipsContent = { [key: string]: string };

  const tooltipContainers = document.querySelectorAll("[tooltip-container]");
  if (tooltipContainers?.length) {
    tooltipContainers?.forEach((container) => {
      container.classList.add("relative");
      const tooltips: NodeListOf<Element> | [] =
        container?.querySelectorAll("[tooltip-id]") ?? [];
      assignTooltipEventsListeners(tooltips);
    });
  }

  function assignTooltipEventsListeners(tooltips: NodeListOf<Element> | []) {
    const tooltipsContent: tooltipsContent = getTooltipsContent(tooltips);
    tooltips.forEach((element) => {
      element.addEventListener("mouseover", (event: Event) => {
        onShowTooltip(event, tooltipsContent);
      });
      element.addEventListener("click", (event: Event) =>
        onShowTooltip(event, tooltipsContent)
      );
    });
  }
  function getTooltipContainer(
    tooltip: HTMLElement | null
  ): HTMLElement | null {
    if (!tooltip) null;
    return tooltip?.closest("[tooltip-container]") as HTMLElement;
  }

  function getTooltipsContent(
    tooltips: NodeListOf<Element> | []
  ): tooltipsContent {
    const tooltipsContent: tooltipsContent = {};
    tooltips?.forEach((el) => {
      const container = getTooltipContainer(el as HTMLElement);
      const id: string = el?.getAttribute("tooltip-id") ?? "";
      const tooltip = container?.querySelector(`[tooltip-for="${id}"]`);
      const tooltipContent = tooltip?.getAttribute("tooltip-content") ?? "";

      if (!tooltip || !tooltipContent || tooltipsContent?.[id]) return;

      tooltipsContent[id as string] = tooltipContent as string;
    });
    return tooltipsContent;
  }

  function removeTooltip(): void {
    const highlightedElsContainer = document?.querySelector(
      "[highligted-tooltips-id]"
    ) as HTMLElement;
    const tooltipId = highlightedElsContainer?.getAttribute(
      "highligted-tooltips-id"
    );
    if (!highlightedElsContainer || !tooltipId) return;
    const tooltipEls = document?.querySelectorAll(
      `[origin-highlighted=${tooltipId}]`
    );
    tooltipEls?.forEach((el) => {
      el?.removeAttribute("origin-highlighted");
    });
    highlightedElsContainer?.remove();
    document?.getElementById("interactive-tooltip")?.remove();
    const overlay = document?.querySelector("[tooltip-container] > .overlay");
    if (overlay) overlay.remove();
  }

  function onShowTooltip(event: Event, tooltipsContent: tooltipsContent): void {
    event.preventDefault();
    event.stopPropagation();
    const target = event.target as HTMLElement;
    const el = target.closest("[tooltip-id]") as HTMLElement;
    const container = getTooltipContainer(el) as HTMLElement;
    const id = el?.getAttribute("tooltip-id") ?? "";
    const content = tooltipsContent?.[id];
    if (!el || !content || !container) return;

    showTooltip(el, content, container);
  }

  function showTooltip(
    target: HTMLElement,
    content: string,
    container: HTMLElement
  ): void {
    const overlay = document.createElement("div") as HTMLElement;
    overlay?.classList?.add(
      "overlay",
      "absolute",
      "top-0",
      "left-0",
      "bottom-0",
      "right-0",
      "w-full",
      "h-full",
      "z-[450]",
      "bg-[rgba(0,0,0,0.8)]",
      "rounded-[50px]"
    );
    overlay?.addEventListener("mouseenter", removeTooltip);
    overlay?.addEventListener("click", removeTooltip);
    container?.appendChild(overlay);
    const tooltipId = target.getAttribute("tooltip-id");
    addHighlightTooltipEls(target, tooltipId!, container);
    const newTooltip = createTooltip(JSON.parse(content), tooltipId!);
    document.body.appendChild(newTooltip);
    positionTooltip(target, newTooltip, container);
  }

  function addHighlightTooltipEls(
    target: HTMLElement,
    tooltipId: string,
    container: HTMLElement
  ) {
    const tooltipHighlightedEls = container?.querySelectorAll(
      `[tooltip-id=${tooltipId}]`
    );
    if (!tooltipId || !tooltipHighlightedEls) return;
    target.setAttribute("highlight-active", "true");
    const highlightedElsContainer = document.createElement("div");
    highlightedElsContainer?.setAttribute("highligted-tooltips-id", tooltipId);
    tooltipHighlightedEls.forEach((tooltipEl) => {
      const originEl = tooltipEl as HTMLElement;
      const originPos = getOffsetElPos(originEl);
      const { top, left } = originPos;
      const elClone = originEl.cloneNode(true) as HTMLElement;
      elClone.classList.add("shadow-1");
      elClone.style.top = `${top}px`;
      elClone.style.left = `${left}px`;
      elClone.style.width = `${originEl.offsetWidth}px`;
      elClone.style.height = `${originEl.offsetHeight}px`;
      highlightedElsContainer.appendChild(elClone);
      originEl.setAttribute("origin-highlighted", tooltipId);
      if (elClone.getAttribute("highlight-active") === "true") {
        elClone.addEventListener("mouseout", () => {
          target.removeAttribute("highlight-active");
          removeTooltip();
        });
      }
    });
    document.body.appendChild(highlightedElsContainer);
  }

  function createTooltip(
    content: tooltip | string,
    id: string
  ): HTMLSpanElement {
    const span = document.createElement("span");
    span.setAttribute("id", "interactive-tooltip");
    span.setAttribute("tooltip-for", id);
    span.classList.add(
      "block",
      "!absolute",
      "shadow",
      "z-[550]",
      "gold-bordered",
      "w-full",
      "min-w-[105px]",
      "max-w-[225px]",
      "desktop-md:max-w-[450px]"
    );
    span.innerHTML =
      typeof content === "string"
        ? content
        : `<span class="tooltip-content block w-full rounded-[5px] p-[1px]">
                      <span class="flex flex-col justify-center bg-dark-gold-gradient p-[15px] desktop-md:p-[30px] shadow rounded-[5px] relative z-30">
                        <h3 class="text-[12px] desktop-sm-[16px] desktop-md-[20px] text-gold pb-[10px]">${content?.title}</h3>
                        <p class="font-jost text-[10px] desktop-sm-[14px] desktop-md-[16px] text-[#FFC99D]">${content?.content}</p>
                      </span>
                    </span>`;
    return span;
  }

  function positionTooltip(
    target: HTMLElement,
    tooltip: HTMLElement,
    container: HTMLElement
  ) {
    let { width: containerWidth = 100, height: containerHeight = 100 } =
      container?.getBoundingClientRect();
    containerWidth =
      window?.innerWidth > containerWidth ? containerWidth : window?.innerWidth;

    const {
      top: targetPosTop,
      left: targetPosLeft,
      bottom: targetPosBottom,
      right: targetPosRight,
    } = target?.getBoundingClientRect();
    const tooltipContent = tooltip.querySelector(
      ".tooltip-content"
    ) as HTMLElement;
    const gap = 30;
    const { width: tooltipW, height: tooltipH } =
      tooltipContent?.getBoundingClientRect();
    const tooltipWidth = tooltipW + gap;
    const tooltipHeight = tooltipH + gap;

    const tooltipPosTopLeft = {
      x: targetPosLeft - tooltipWidth,
      y: targetPosTop - tooltipHeight,
    };
    const tooltipPosTopRight = {
      x: targetPosRight,
      y: targetPosTop,
    };
    const tooltipPosBottomLeft = {
      x: targetPosLeft - tooltipWidth,
      y: targetPosBottom,
    };
    const tooltipPosBottomRight = {
      x: targetPosRight,
      y: targetPosBottom,
    };

    if (
      tooltipPosBottomRight.x + tooltipWidth < containerWidth &&
      tooltipPosBottomRight.y + tooltipHeight < containerHeight
    ) {
      console.log("tooltipPosBottomRight");
      setTooltipPos(tooltip, tooltipPosBottomRight.y, tooltipPosBottomRight.x);
      return;
    }
    if (
      tooltipPosBottomRight.x + tooltipWidth > containerWidth &&
      tooltipPosBottomRight.y + tooltipHeight < containerHeight
    ) {
      console.log("tooltipPosBottomLeft");
      setTooltipPos(tooltip, tooltipPosBottomLeft.y, tooltipPosBottomLeft.x);
      return;
    }
    if (
      tooltipPosBottomRight.x + tooltipWidth < containerWidth &&
      tooltipPosBottomRight.y + tooltipHeight > containerHeight
    ) {
      console.log("tooltipPosTopRight");
      setTooltipPos(tooltip, tooltipPosTopRight.y, tooltipPosTopRight.x);
      return;
    }
    if (
      tooltipPosBottomRight.x + tooltipWidth > containerWidth &&
      tooltipPosBottomRight.y + tooltipHeight > containerHeight
    ) {
      console.log("tooltipPosTopLeft");
      setTooltipPos(tooltip, tooltipPosTopLeft.y, tooltipPosTopLeft.x);
      return;
    }
  }

  function setTooltipPos(
    tooltip: HTMLElement,
    tooltipPosTop: number,
    tooltipPosLeft: number
  ) {
    const tooltipStyleTop = `${tooltipPosTop?.toFixed(0)}px`;
    const tooltipStyleLeft = `${tooltipPosLeft?.toFixed(0)}px`;
    tooltip.style.top = tooltipStyleTop;
    tooltip.style.left = tooltipStyleLeft;
  }

  function getOffsetElPos(el: HTMLElement) {
    const rect = el.getBoundingClientRect();
    const scrollLeft = window.scrollX || document.documentElement.scrollLeft;
    const scrollTop = window.scrollY || document.documentElement.scrollTop;
    return {
      top: (rect.top + scrollTop)?.toFixed(),
      left: (rect.left + scrollLeft)?.toFixed(),
    };
  }
</script>
